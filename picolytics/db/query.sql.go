// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const autocertCacheDelete = `-- name: AutocertCacheDelete :exec
DELETE FROM autocert_cache WHERE key = $1
`

func (q *Queries) AutocertCacheDelete(ctx context.Context, key string) error {
	_, err := q.db.Exec(ctx, autocertCacheDelete, key)
	return err
}

const autocertCacheGet = `-- name: AutocertCacheGet :one
SELECT data FROM autocert_cache WHERE key = $1
`

func (q *Queries) AutocertCacheGet(ctx context.Context, key string) ([]byte, error) {
	row := q.db.QueryRow(ctx, autocertCacheGet, key)
	var data []byte
	err := row.Scan(&data)
	return data, err
}

const autocertCachePut = `-- name: AutocertCachePut :exec
INSERT INTO autocert_cache (key, data, created_at, updated_at)
VALUES ($1, $2, NOW(), NOW())
ON CONFLICT (key)
DO UPDATE SET data = EXCLUDED.data, updated_at = NOW()
`

type AutocertCachePutParams struct {
	Key  string
	Data []byte
}

func (q *Queries) AutocertCachePut(ctx context.Context, arg AutocertCachePutParams) error {
	_, err := q.db.Exec(ctx, autocertCachePut, arg.Key, arg.Data)
	return err
}

type CreateEventsParams struct {
	DomainID  int32
	SessionID int64
	VisitorID string
	Name      string
	Path      string
	Referrer  string
	LoadTime  int32
	Ttfb      int32
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    updated_at, bounce, domain_id, exit_path, ---- values updated with each event ----
    visitor_id, entry_path, ---- static values from first event ---- 
    country, latitude, longitude, subdivision, city, ---- geoip lookup ----
    browser, browser_version, os, os_version, platform, device_type, bot, screen_w, screen_h, timezone, pixel_ratio, pixel_depth, ---- useragent ----
    utm_source, utm_medium, utm_campaign, utm_content, utm_term ---- query string ----
) VALUES (
  CURRENT_TIMESTAMP, TRUE, $1, $2,
  $3, $4,
  $5, $6, $7, $8, $9,
  $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21,
  $22, $23, $24, $25, $26
)
RETURNING id
`

type CreateSessionParams struct {
	DomainID       int32
	ExitPath       string
	VisitorID      pgtype.Text
	EntryPath      string
	Country        pgtype.Text
	Latitude       pgtype.Float8
	Longitude      pgtype.Float8
	Subdivision    pgtype.Text
	City           pgtype.Text
	Browser        pgtype.Text
	BrowserVersion pgtype.Text
	Os             pgtype.Text
	OsVersion      pgtype.Text
	Platform       pgtype.Text
	DeviceType     pgtype.Text
	Bot            bool
	ScreenW        pgtype.Int4
	ScreenH        pgtype.Int4
	Timezone       pgtype.Text
	PixelRatio     pgtype.Float8
	PixelDepth     pgtype.Int4
	UtmSource      pgtype.Text
	UtmMedium      pgtype.Text
	UtmCampaign    pgtype.Text
	UtmContent     pgtype.Text
	UtmTerm        pgtype.Text
}

// -- MUST call this in a transaction after GetSession ----
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (int64, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.DomainID,
		arg.ExitPath,
		arg.VisitorID,
		arg.EntryPath,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.Subdivision,
		arg.City,
		arg.Browser,
		arg.BrowserVersion,
		arg.Os,
		arg.OsVersion,
		arg.Platform,
		arg.DeviceType,
		arg.Bot,
		arg.ScreenW,
		arg.ScreenH,
		arg.Timezone,
		arg.PixelRatio,
		arg.PixelDepth,
		arg.UtmSource,
		arg.UtmMedium,
		arg.UtmCampaign,
		arg.UtmContent,
		arg.UtmTerm,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getEvent = `-- name: GetEvent :one
SELECT id, name, domain_id, path, referrer, visitor_id, session_id, load_time, ttfb, created_at FROM events
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEvent(ctx context.Context, id int64) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DomainID,
		&i.Path,
		&i.Referrer,
		&i.VisitorID,
		&i.SessionID,
		&i.LoadTime,
		&i.Ttfb,
		&i.CreatedAt,
	)
	return i, err
}

const getSalt = `-- name: GetSalt :one
SELECT salt, created_at FROM salt LIMIT 1
`

func (q *Queries) GetSalt(ctx context.Context) (Salt, error) {
	row := q.db.QueryRow(ctx, getSalt)
	var i Salt
	err := row.Scan(&i.Salt, &i.CreatedAt)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id FROM sessions
WHERE visitor_id = $1
AND updated_at > CURRENT_TIMESTAMP - $2::interval
ORDER by updated_at DESC
LIMIT 1
`

type GetSessionParams struct {
	VisitorID pgtype.Text
	Column2   pgtype.Interval
}

func (q *Queries) GetSession(ctx context.Context, arg GetSessionParams) (int64, error) {
	row := q.db.QueryRow(ctx, getSession, arg.VisitorID, arg.Column2)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listEvents = `-- name: ListEvents :many
SELECT id, name, domain_id, path, referrer, visitor_id, session_id, load_time, ttfb, created_at FROM events
ORDER BY id DESC
`

func (q *Queries) ListEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DomainID,
			&i.Path,
			&i.Referrer,
			&i.VisitorID,
			&i.SessionID,
			&i.LoadTime,
			&i.Ttfb,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pruneEvents = `-- name: PruneEvents :exec
DELETE FROM events WHERE created_at <= CURRENT_TIMESTAMP - $1::interval
`

func (q *Queries) PruneEvents(ctx context.Context, theInterval pgtype.Interval) error {
	_, err := q.db.Exec(ctx, pruneEvents, theInterval)
	return err
}

const pruneSessions = `-- name: PruneSessions :exec
DELETE FROM sessions WHERE updated_at <= CURRENT_TIMESTAMP - $1::interval
`

func (q *Queries) PruneSessions(ctx context.Context, theInterval pgtype.Interval) error {
	_, err := q.db.Exec(ctx, pruneSessions, theInterval)
	return err
}

const updateSalt = `-- name: UpdateSalt :exec
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM salt) OR (SELECT EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - created_at)) / 3600 > 0 FROM salt LIMIT 1) THEN
        DELETE FROM salt;
        INSERT INTO salt (salt) VALUES (gen_random_uuid());
    END IF;
END $$
`

func (q *Queries) UpdateSalt(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateSalt)
	return err
}

const updateSession = `-- name: UpdateSession :exec
UPDATE sessions 
SET 
    bounce = CASE WHEN $3::text NOT IN ('hidden', 'ping') THEN FALSE ELSE bounce END,
    updated_at = CURRENT_TIMESTAMP,
    exit_path = $1,
    duration = EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - created_at))
WHERE id = $2
`

type UpdateSessionParams struct {
	ExitPath  string
	ID        int64
	EventName string
}

// -- MUST call this in a transaction after GetSession ----
func (q *Queries) UpdateSession(ctx context.Context, arg UpdateSessionParams) error {
	_, err := q.db.Exec(ctx, updateSession, arg.ExitPath, arg.ID, arg.EventName)
	return err
}

const upsertDomain = `-- name: UpsertDomain :one
INSERT INTO domains (domain_name)
VALUES ($1)
ON CONFLICT (domain_name) DO UPDATE
SET domain_name = EXCLUDED.domain_name
RETURNING domain_id
`

func (q *Queries) UpsertDomain(ctx context.Context, domainName string) (int32, error) {
	row := q.db.QueryRow(ctx, upsertDomain, domainName)
	var domain_id int32
	err := row.Scan(&domain_id)
	return domain_id, err
}
